#!/usr/bin/env python
# encoding: utf-8
# Copyright 2018, The RouterSploit Framework (RSF) by Threat9 All rights reserved.
import os
import threading
import time
from future.utils import with_metaclass, iteritems
from itertools import chain
from functools import wraps
from core.Printer import print_status, ThreadOutputStream
from core.Option import Option
GLOBAL_OPTS = {}


class Protocol:
    CUSTOM = "custom"
    TCP = "custom/tcp"
    UDP = "custom/udp"
    FTP = "ftp"
    FTPS = "ftps"
    SSH = "ssh"
    TELNET = "telnet"
    HTTP = "http"
    HTTPS = "https"
    SNMP = "snmp"


class ExploitOptionsAggregator(type):
    """ Metaclass for exploit base class.
    Metaclass is aggregating all possible Attributes that user can set
    for tab completion purposes.
    """
    def __new__(mcs, names, bases, attrs):
        try:
            base_exploit_attributes = chain([base.exploit_attributes for base in bases])
        except AttributeError:
            attrs["exploit_attributes"] = {}
        else:
            attrs["exploit_attributes"] = {k: v for d in base_exploit_attributes for k, v in iteritems(d)}
        for key, value in iteritems(attrs):
            if isinstance(value, Option):
                value.label = key
                attrs["exploit_attributes"].update({key: [value.display_value, value.description]})
            elif key == "__info__":
                attrs["_{}{}".format(names, key)] = value
                del attrs[key]
            elif key in attrs["exploit_attributes"]:
                del attrs["exploit_attributes"][key]
        return super(ExploitOptionsAggregator, mcs).__new__(mcs, names, bases, attrs)


class BaseExploit(with_metaclass(ExploitOptionsAggregator, object)):
    @property
    def options(self):
        """ Returns list of options that user can set.
        Returns list of options aggregated by
        ExploitOptionsAggregator metaclass that user can set.
        :return: list of options that user can set
        """
        return list(self.exploit_attributes.keys())

    def __str__(self):
        return self.__module__.split('.', 2).pop().replace('.', os.sep)


class Exploit(BaseExploit):
    """ Base class for exploits """
    target_protocol = Protocol.CUSTOM

    def run(self):
        raise NotImplementedError("Please implement run method")

    def check(self):
        raise NotImplementedError("Please implement check method")

    @staticmethod
    def run_thread(thread_number: int, target_function: any, *args, **kwargs) -> None:
        """ Run function across specified number of threads
        :param int thread_number: number of threads that should be executed
        :param func target_function: function that should be executed across specified number of threads
        :param any args: args passed to target_function
        :param any kwargs: kwargs passed to target function
        :return None
        """
        threads = []
        threads_running = threading.Event()
        threads_running.set()
        for thread_id in range(int(thread_number)):
            thread = threading.Thread(target=target_function, args=chain((threads_running, ), args), kwargs=kwargs, name="thread-{}".format(thread_id))
            threads.append(thread)
            print_status("{} thread is starting...".format(thread.name))
            thread.start()
        start = time.time()
        try:
            while thread.isAlive():
                thread.join(1)
        except KeyboardInterrupt:
            threads_running.clear()
        for thread in threads:
            thread.join()
            print_status("{} thread is terminated".format(thread.name))
        print_status("Elapsed time: {} seconds.".format(time.time() - start))


def multi(fun):
    """ Decorator for exploit.Exploit class
    Decorator that allows to feed exploit using text file containing
    multiple targets definition. Decorated function will be executed
    as many times as there is targets in the feed file.
    WARNING:
    Important thing to remember is fact that decorator will
    suppress values returned by decorated function. Since method that
    perform attack is not supposed to return anything this is not a problem.
    """
    @wraps(fun)
    def wrapper(self, *args, **kwargs):
        if self.target.startswith("file://"):
            original_target = self.target
            original_port = self.port
            _, _, feed_path = self.target.partition("file://")
            try:
                with open(feed_path) as file_handler:
                    for target in file_handler:
                        target = target.strip()
                        if not target:
                            continue
                        self.target, _, port = target.partition(":")
                        if port:
                            self.port = port
                        else:
                            self.port = original_port
                        fun(self, *args, **kwargs)
                    self.target = original_target
                    self.port = original_port
                    return
            except IOError:
                return
        else:
            return fun(self, *args, **kwargs)
    return wrapper


class DummyFile(object):
    """ Mocking file object. Optimization for the "mute" decorator. """
    def write(self, x):
        pass


def mute(fun):
    """ Suppress function from printing to sys.stdout """
    @wraps(fun)
    def wrapper(self, *args, **kwargs):
        ThreadOutputStream.setdefault(threading.current_thread(), []).append(DummyFile())
        try:
            return fun(self, *args, **kwargs)
        finally:
            ThreadOutputStream[threading.current_thread()].pop()
    return wrapper


class LockedIterator(object):
    def __init__(self, iterator):
        self.lock = threading.Lock()
        self.iterator = iterator.__iter__()

    def __iter__(self):
        return self

    def next(self):
        self.lock.acquire()
        try:
            item = next(self.iterator)
            if type(item) is tuple:
                return (item[0].strip(), item[1].strip())
            elif type(item) is str:
                return item.strip()
            return item
        finally:
            self.lock.release()
